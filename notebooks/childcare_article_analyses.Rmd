# Data Preparation

```{r}
library(here)
knitr::purl(here("notebooks/childcare_article_analyses.Rmd"), here("R/childcare_article_analyses.R"))
```

```{r}
library(vegan)
library(microbiome)
library(tidyverse)
library(here)
library(future)
library(furrr)
library(broom)
library(ggpubr)
library(patchwork)
```

```{r}
# load data and helper functions
source("https://raw.githubusercontent.com/HenrikEckermann/in_use/master/bayesian_helper.R")
source("https://raw.githubusercontent.com/HenrikEckermann/in_use/master/mb_helper.R")
source("https://raw.githubusercontent.com/HenrikEckermann/in_use/master/reporting.R")
```

```{r}
load(here("data/data_transfer.RData"))
source(here("R/read.R"))
```

```{r}
# take over the meta variables I created in other docs
meta_new <- data_transfer[, 1:9] 
```

```{r}
# create catories for bf and childcare and specifically for ccyes vs rest
meta_new <- meta_new %>%
  mutate(
      groups = ifelse(time == "pre" & cc == "no", "noCCpre", ifelse(
          time == "pre" & cc == "yes", "CCpre", ifelse(
              time == "post" & cc == "no", "noCCpost", "CCpost"))),
      bf = ifelse(bf_ratio <= 0.25, "lowBF", ifelse(
          bf_ratio <0.75, "mediumBF", "highBF")),
      ccpost = ifelse(groups == "CCpost", 1, 0)) %>% 
  mutate(
      groups = as.factor(groups), 
      bf = as.factor(bf), 
      ccpost = as.factor(ccpost))
```

```{r}
siblings <- readxl::read_excel(here("data/meta_data/siblings_addon_yvonne.xlsx")) %>% 
    filter(subject_id %in% meta_new$subject_id)
```

```{r}
# add confounding variables
confounders <- foreign::read.spss(here("data/meta_data/bibo_confounders.sav"), to.data.frame = T) %>%
    select(subject_id = ID, childsex, delivery = DELIVERYmode, birthweight = BIRTHWEIGTH) %>%
    filter(subject_id %in% meta_new$subject_id) %>% 
    left_join(siblings, by = "subject_id") %>% 
    mutate(
        sibling = ifelse(sibling == 0, 0, 1),
        csection = ifelse(
        delivery == "natuurlijke bevalling", 0,
            ifelse(delivery == "6", NA, 
               ifelse(delivery == "999", NA,
                      ifelse(delivery == "pomp", 0, 1)))))
meta_new <- meta_new %>% left_join(confounders, by = "subject_id")
```

```{r}
# create new pseq object (read.R results in the object "genus" Leo created)
otu <- otu_to_df(genus, transpose = FALSE)
otu <- otu %>% 
    select(species, meta_new$sample_id) %>% 
    df_to_otu()
pseq <- phyloseq(otu, df_to_sd(meta_new), tax_table(genus))
# add diversity indeces to sample data
diversities <- 
    global(pseq, index = "all") %>% 
    select(contains("diversities")) %>% 
    rownames_to_column("sample_id")
colnames(diversities) <- gsub("diversities_", "", colnames(diversities))

sample_data(pseq) <- 
    sd_to_df(pseq) %>% 
    left_join(diversities, by = "sample_id") %>%
    df_to_sd()
meta <- sd_to_df(pseq)
# clr and relative abundance transformation to deal with compositionality of mb data
pseq.clr <- microbiome::transform(pseq, transform = "clr")
pseq.rel <- microbiome::transform(pseq, "compositional")
```

# PCA

A PCA using CLR transformed values displays the Aitchison distance.

```{r}
otus.clr <- otu_to_df(pseq.clr)
colnames(otus.clr)[which(colnames(otus.clr) == "Clostridium \\(sensu stricto\\)")] <- "Clostridium_sensu_stricto"
colnames(otus.clr) <- c("sample_id", gsub("_", "", colnames(otus.clr)[-1]))
colnames(otus.clr) <- gsub("\\.", "", colnames(otus.clr))
colnames(otus.clr) <- gsub(" ", "", colnames(otus.clr))
genus <- colnames(otus.clr)[-1]
data <- sd_to_df(pseq.clr) %>%
    left_join(otus.clr, by = "sample_id")
data$childsex <- as.factor(data$childsex)
data$delivery <- as.factor(data$delivery)
data <- data %>% mutate(birthweight_s = scale(birthweight)[, 1])


# PCA with CLR values (euclidean distance of clr transformed values = Aitchison distance) 
pcx <- prcomp(otus.clr %>% column_to_rownames("sample_id"))
# extract loadings
pcx_rot <- 
    pcx$rotation %>%
        as.tibble() %>%
        mutate_all(function(x) x*10) %>%
        add_column(genus = rownames(pcx$rotation))

# add PCs to data
princomps <- pcx$x %>% as.data.frame() %>%
    rownames_to_column("sample_id") %>%
    select(PC1, PC2, PC3, PC4, PC5, sample_id)
data <- data %>% left_join(princomps, by = "sample_id") 
                   
# how much variance do pcs explain?
pc1 <- round(pcx$sdev[1]^2/sum(pcx$sdev^2),2)
pc2 <- round(pcx$sdev[2]^2/sum(pcx$sdev^2),2)
pc3 <- round(pcx$sdev[3]^2/sum(pcx$sdev^2),2)
pc4 <- round(pcx$sdev[4]^2/sum(pcx$sdev^2),2)
pc5 <- round(pcx$sdev[5]^2/sum(pcx$sdev^2),2)                   
```

```{r}
p_versions <- c(1:4)
# just to compare with others:
#stats::biplot(pcx)
# biplots
biplot_cc <- biplot(pseq.clr, color = "cc", split_by = "time")
map2(biplot_cc, p_versions, ~ggsave(plot = .x, filename = here(glue("fig/aitchison_pca_cc_{.y}.png"))))
biplot_time <- biplot(pseq.clr, split_by = "cc", connect_series = "time")
map2(biplot_time, p_versions, ~ggsave(plot = .x, filename = here(glue("fig/aitchison_pca_time_{.y}.png"))))
biplot_csection <- biplot(pseq.clr, color = "csection")
biplot_sibling <- biplot(pseq.clr, color = "sibling")
```

```{r}
biplot_csection
```

# Multiple Impuation

```{r}
# I recode the contrasts so that I have the comparisons I want:
# the intercept will reflect our group we want to compare to others (cc post)
# the cc coefficient then compares to no cc post, the time coefficent 
# to cc pre and the interaction to no cc pre
# contrasts(data$cc)[1, 1] <- 1
# contrasts(data$cc)[2, 1] <- 0
# contrasts(data$time)[1, 1] <- 1
# contrasts(data$time)[2, 1] <- 0

library(mice)
# Next I impute data using predictive mean matching (PMM). PMM is
# less difficult to specify. I use the PCs to impute instead of all 
# genus abundances since these are correlated
data_imp <- data %>% 
    select(
        -everything(), 
        subject_id, 
        age_d_s, 
        time, 
        cc, 
        bf_count_s, 
        sibling,
        birthweight_s,
        csection,
        PC1,
        PC2,
        PC3,
        PC4,
        PC5) %>%
    mice(m = 10, method = "pmm", print = F, seed = 412) %>%
    mice::complete("all")
# This I use to join genus abundances again
deselect_col <- colnames(data_imp[[1]])
data_lj <- data %>% select(-deselect_col, subject_id, time)
data_imp <- map(data_imp, ~.x %>% left_join(data_lj, by = c("subject_id", "time")))
```

```{r}
# PMM does not understand that for one subject the sibling/csection must be similar, so I manually always use the pre
# sibling which is random.
data_imp <- map(data_imp, function(x) {
    #x[x$subject_id == "453" & x$time == "post", "sibling"] <- x[x$subject_id == "453" & x$time == "pre", "sibling"]
    sibling_pre <- x[x$subject_id == 453 & x$time == "pre", "sibling"]
    csection_pre_449 <- x[x$subject_id == 449 & x$time == "pre", "csection"]
    csection_pre_369 <- x[x$subject_id == 369 & x$time == "pre", "csection"]
    x <- x %>% mutate(
        sibling = ifelse(subject_id == "453", sibling_pre, sibling),
        csection = ifelse(subject_id == "449", csection_pre_449, 
                          ifelse(subject_id == "369", csection_pre_369, csection)),
        sibling = as.factor(sibling),
        csection = as.factor(csection)
        
    )

})
```

```{r}
data_imp$`1` %>% group_by(sibling, cc) %>% summarise(n= n())
#data_imp$`1`$csection %>% contrasts
#data_imp$`1`$sibling %>% contrasts
```

```{r}
# data_imp$`1`$csection <- data_imp$`1`$csection %>% as.factor()
# data_imp$`1`$sibling <- data_imp$`1`$sibling %>% as.factor()
# data_imp$`2`$csection <- data_imp$`1`$csection %>% as.factor()
# data_imp$`3`$csection <- data_imp$`2`$csection %>% as.factor()
# data_imp$`1`$csection %>% contrasts
# contrasts(data_imp$`2`$csection) <- contr.sum
# contrasts(data_imp$`2`$cc) <- contr.sum
# contrasts(data_imp$`2`$time) <- contr.sum
# data_imp$`2`$sibling <- as.factor(data_imp$`2`$sibling)
# contrasts(data_imp$`2`$sibling) <- contr.sum
# ct_object <- data_imp$`3`$csection %>% contrasts
# ct_object[1,1] <- 1
# ct_object[2,1] <- 0
# contrasts(data_imp$`3`$csection) <- ct_object
# data_imp$`3`$csection %>% contrasts 
# data_imp$`2`$csection %>% contrasts 
```

```{r}
# data_imp$`4`$time <- as.numeric(data_imp$`4`$time)
# data_imp$`4`$cc <- as.numeric(data_imp$`4`$cc)
# data_imp$`4`$sibling <- as.numeric(data_imp$`4`$sibling)
# data_imp$`4` <- data_imp$`4`  %>% mutate(
#     cc = ifelse(cc == 1, 0, 1),
#     time = ifelse(time==1, 0, 1)
# )
# data_imp$`4` %>% head()
```



# Differential abundance testing

```{r}
# specify prior (i did not specifiy sigma and alpha)
prior <- c(
            set_prior("normal(0, 2)", class = "b"),
            set_prior("exponential(25)", class = "sd"),
            set_prior("normal(0, 10)", class = "Intercept"),
            set_prior("lkj(2)", class = "cor"))
prior_refit <- c(
            set_prior("normal(0, 2)", class = "b"),
            set_prior("exponential(55)", class = "sd"),
            set_prior("normal(0, 10)", class = "Intercept"),
            set_prior("lkj(2)", class = "cor"))
prior_refit2 <- c(
            set_prior("normal(0, 2)", class = "b"),
            set_prior("exponential(65)", class = "sd"),
            set_prior("normal(0, 10)", class = "Intercept"),
            set_prior("lkj(2)", class = "cor"))

prior_refit3 <- c(
            set_prior("normal(0, 2)", class = "b"),
            set_prior("exponential(75)", class = "sd"),
            set_prior("normal(0, 10)", class = "Intercept"),
            set_prior("lkj(2)", class = "cor"))

prior_refit4 <- c(
            set_prior("normal(0, 2)", class = "b"),
            set_prior("exponential(100)", class = "sd"),
            set_prior("normal(0, 10)", class = "Intercept"),
            set_prior("lkj(2)", class = "cor"))


control <-  list(adapt_delta = 0.9999, max_treedepth = 15)
folder <- here("models/differential_abundance/skew_normal/mice/")

# define fitting function for fixed sigma for mice object
brm_sn <- function(genus) {
    # specify formula
    f_d <- as.formula(glue("{genus} ~ 1 + time*cc + age_d_s + bf_count_s + (1+ time + age_d_s + bf_count_s|subject_id)"))
    formula <- bf(f_d)
    # give individual model name for storage
    model_file <- glue("{folder}/{genus}_full_multiple")
    #fit model
    brm_multiple(
        family = skew_normal(), data = data_imp, formula = formula,
        chains = 4, warmup = 1000,
        control = control, prior = prior, file = model_file
        )
    
}



brm_sn_multiple_fut_comp <- function(genus) future({
    tryCatch(
        {
            # specify formula
            f_d <- as.formula(glue("{genus} ~ 1 + time*cc + age_d_s + bf_count_s + csection * sibling + (1+ time + age_d_s + bf_count_s|subject_id)"))
            formula <- bf(f_d)
            # give individual model name for storage
            model_file <- glue("{folder}{genus}_full_multiple_comp")
            #fit model
            brm_multiple(
                family = skew_normal(), data = data_imp, formula = formula,
                chains = 4, warmup = 1000,
                control = control, prior = prior, file = model_file
                )
        },
        error=function(cond) {
            # Choose a return value in case of error
            return(cond)
        }
    )
})
```

```{r}
#plan(multiprocess)
#map(files[excluded_ids], brm_sn_multiple_fut_refit)
#models <- future_map(models_fut, value)
```

```{r}
plan(multiprocess)
selection <- c(
    "Granulicatella", 
    "Enterococcus", 
    "Streptococcusintermediusetrel", 
    "Streptococcusbovisetrel", 
    "Streptococcusmitisetrel", 
    "Bifidobacterium"
)
#models_fut <- map(selection, brm_sn_multiple_fut_comp)
models <- map(models_fut, value)
```

```{r}
tidy(models[[1]])
```

```{r}
#refit_gs <- gsub("_full_multiple.rds", "", list.files(here("models/differential_abundance/skew_normal/mice/refit")))
```

```{r}
#for (genus in converged_models[excluded_ids]) {
#    fit_fut <- brm_sn_multiple_fut(genus)
#    fit <- values(fit_fut)
#    print(summary(fit))
#}
```

```{r}
#map(refit_gs, ~file.remove(here(glue("models/differential_abundance/skew_normal/mice/{.x}_full_multiple.rds"))))
#map(genus_refit[excluded_ids], ~file.remove(here(glue("models/differential_abundance/skew_normal/mice/{.x}"))))
```

```{r}
converged_models <- list.files(here(glue("models/differential_abundance/skew_normal/mice/")))
converged_models <- gsub("_full_multiple.rds", "", converged_models)
converged_models <- converged_models[-123]
#converged_models
```

```{r}
# model screening/excluding 
return_diag <- function(fit, genus) {
    sum_fit <- summary(fit)
    params <- rbind(sum_fit$fixed, sum_fit$random$subject_id, sum_fit$spec_pars) %>% as.data.frame()
    # extract n of divergent transitions
    n_divergent <- nuts_params(fit) %>% 
        filter(Parameter == "divergent__") %>% 
        summarise(n = sum(Value))
    # extract n of rhat > 1.1        
    n_high_rhat <- dim(filter(params, Rhat >= 1.1))[1]
    # check if there are rhat > 1.1 or divergent transitions
    if (n_high_rhat > 0) {
        message(glue("{genus} has {n_high_rhat} high Rhat parameter values"))
        return(FALSE)
    } else if (n_divergent$n > 0){
        message(glue("{genus} has {n_divergent$n} divergent transitions"))
        return(FALSE)
    } 
    TRUE
}

calc_mu_diff <- function(model, summarise = TRUE, stat = "mean") {
    df <- posterior_samples(model) %>%
        select(
            glue("b_Intercept"), 
            glue("b_ccyes"), 
            glue("b_timepost"), 
            glue("b_timepost:ccyes"), 
            glue("b_age_d_s"), 
            glue("b_bf_count_s"),
            glue("b_sibling1"),
            glue("b_csection1"),
            glue("b_csection1:sibling1")
        ) %>%
        rename(
            noccpre = glue("b_Intercept"), 
            ccpre = glue("b_ccyes"),
            noccpost = glue("b_timepost"),
            ccpost = glue("b_timepost:ccyes"),
            age = glue("b_age_d_s"),
            bf = glue("b_bf_count_s"),
            csection = glue("b_csection1"),
            sibling = glue("b_sibling1"),
            csection_sibling = glue("b_csection1:sibling1")
        ) %>%
        mutate(
            ccpost = noccpre + ccpre + noccpost + ccpost,
            noccpost = noccpre + noccpost,
            ccpre = noccpre + ccpre
    )    
    if (summarise) {
        df <- df %>% gather(group, value) %>%
            group_by(group) %>%
            do(data.frame(
                central = ifelse(stat == "median", median(.$value), mean(.$value)),
                lower = hpdi(.$value)[1],
                upper = hpdi(.$value)[2]
            ))
        
    }
    df 
}

plot_diff <- function(model) {
    df_sum <- calc_mu_diff(model)
    df <- calc_mu_diff(model, summarise = F)
    # plot
    df %>% gather(group, value) %>%
        ggplot(aes(x = group, value)) +
            geom_jitter(alpha = 0.05, color = "darkred") +
            geom_point(data = df_sum, aes(x = group, y = central), size = 2, color = "red") +
            geom_errorbar(data = df_sum, aes(x = group, y = central,  ymin = lower, ymax = upper), color = "darkred") +
            theme_bw()
}
compare_groups <- function(fit, genus) {
    df <- calc_mu_diff(fit,  summarise = F)
    df <- df %>% 
        mutate(            
            ccpost_ccpre = ccpost - ccpre,
            ccpost_noccpre = ccpost - noccpre,
            ccpost_noccpost = ccpost - noccpost,
            noccpre_ccpre = noccpre - ccpre,
            noccpost_noccpre = noccpost - noccpre,
            noccpost_ccpre = noccpost - ccpre) %>%
        select(ccpost_ccpre, ccpost_noccpre, ccpost_noccpost, noccpre_ccpre, noccpost_noccpre, noccpost_ccpre, age, bf, csection, sibling, csection_sibling) %>%
        gather(comparison, value) %>%
        group_by(comparison) %>%
        do(data.frame(
            mean = mean(.$value),
            lower = hpdi(.$value)[1],
            upper = hpdi(.$value)[2],
            prob = mean(.$value < 0)
        ))
    df %>% add_column(genus = genus)
}

return_comparisons <- function(genus) {
    fit_fut <- brm_sn_multiple_fut_comp(genus)
    fit <- value(fit_fut)
    # can we go on with the model?
    if (!return_diag(fit, genus)) {
        return(genus = NA)
    }
    
    # else go on and compare groups
    compare_groups(fit, genus)
}
```

```{r}
plan(multiprocess)
#comp_all <- future_map(converged_models, return_comparisons)
comp_all_comp <- future_map(selection, return_comparisons)
```

```{r}
# I used this until all models converged
excluded_ids <- which(is.na(comp_all_comp))
#converged_models[excluded_ids]
comp_all_complete <- comp_all[!is.na(comp_all)]
length(comp_all)
#map(files[excluded_ids], ~file.remove(here(glue("models/differential_abundance/skew_normal/mice/{.x}_full_multiple.rds"))))
comp_all %>% head(2)
```

```{r}
comp_all_comp
```

```{r}
comp_all_df <- map_df(comp_all_comp, bind_rows)

# the input for the plot_comp function will be nested dfs:
comp_all_nested <- comp_all_df %>% 
    group_by(comparison) %>%
    nest()

plot_comp <- function(data, comp) {
    all_comp <- data %>% mutate(prob = report_star_nondirectional(prob))
    n_genera <- length(all_comp$genus)
    part1 <- all_comp[1:n_genera/2, ]
    part2 <- all_comp[-c(1:n_genera/2), ]
    p <- map(list(part1, part2), ~ ggplot(
        .x, aes(genus, mean, label = prob)) +
        geom_pointrange(aes(ymin = lower, ymax = upper), size = 0.2) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        geom_text(nudge_y = 1) +
        geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
        ylim(-2, 2) +
        ggtitle(comp) +
        coord_flip() +
        theme_bw(base_size = 8))
    
    p
}


comparison_plots <- map2(comp_all_nested$data, comp_all_nested$comparison, plot_comp)
comparison_plots
```

```{r}
unique(comp_all_df$comparison)

comp_article_1 <- comp_all_df %>% filter(comparison  %in% c("ccpre_noccpre", "ccpost_noccpost"))
comp_article_2 <- comp_all_df %>% filter(comparison  %in% c("ccpost_ccpre", "noccpost_noccpre"))

filter_genus_1 <- comp_article_1 %>% 
    filter((comparison == "noccpre_ccpre" & (prob <= 0.05 | prob >= 0.95)) | (comparison == "ccpost_noccpost" & (prob <= 0.05 | prob >= 0.95)))
filter_genus_2 <- comp_article_2 %>% 
    filter((comparison == "ccpost_ccpre" & (prob <= 0.05 | prob >= 0.95)) | (comparison == "noccpost_noccpre" & (prob <= 0.05 | prob >= 0.95)))

plot_comp_article <- function(data, filter_genus) {
    all_comp <- data %>% mutate(prob = ifelse(prob <= 0.05 | prob >= 0.95, "*", "")) %>%
        filter(genus %in% filter_genus$genus) %>%
        as_tibble()  %>%
        mutate(comparison = ifelse(comparison == 'ccpost_ccpre', "CC_POST - CC_PRE",
                                   ifelse(comparison == 'ccpost_noccpost', "CC_POST - HOME_POST", 
                                          ifelse(comparison == 'ccpost_noccpre', "CC_POST - HOME_PRE", 
                                                 ifelse(comparison == 'ccpre_noccpost', "CC_PRE - HOME_POST", 
                                                        ifelse(comparison == 'ccpre_noccpre', "CC_PRE - HOME_PRE", 
                                                               ifelse(comparison == 'ccpre_noccpre', "CC_PRE - HOME_PRE", "HOME_POST - HOME_PRE"))))))) 
    p <- ggplot(all_comp, aes(genus, mean, label = prob, ymin = lower, ymax = upper, color = prob)) +
        geom_pointrange(size = 1) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        #geom_text(nudge_y = - 0.2, size = 3) +
        geom_hline(yintercept = 0, linetype = "dashed", color = "#404040") +
        scale_color_manual(values = c("#404040", "#ca0020")) +
        ylim(-1.75, 0.75) +
        facet_wrap(~comparison) +
        xlab("") + ylab(bquote(paste("Difference in ", mu))) +
        coord_flip() +
        theme_bw(base_size = 18) +
        theme() +
        theme(legend.position="none")
    
    p
}

comparison_plots_article_1 <- plot_comp_article(comp_article_1, filter_genus_1)
comparison_plots_article_2 <- plot_comp_article(comp_article_2, filter_genus_2)

comparison_plots_article_1
comparison_plots_article_2
```

```{r}
unique(comp_all_df$comparison)
comp_article_3 <- comp_all_df %>% filter(comparison %in% c("age", "bf"))

filter_genus_3 <- comp_article_3 %>% 
    filter((comparison == "age" & (prob <= 0.05 | prob >= 0.95)) | (comparison == "bf" & (prob <= 0.05 | prob >= 0.95)))
        
                                    

plot_comp_article <- function(data, filter_genus) {
    all_comp <- data %>% mutate(prob = ifelse(prob <= 0.05 | prob >= 0.95, "*", "")) %>%
        filter(genus %in% filter_genus$genus) %>%
        as_tibble()
    p <- ggplot(all_comp, aes(genus, mean, label = prob, ymin = lower, ymax = upper, color = prob)) +
        geom_pointrange(size = 1) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        #geom_text(nudge_y = - 0.2, size = 3) +
        geom_hline(yintercept = 0, linetype = "dashed", color = "#404040") +
        scale_color_manual(values = c("#404040", "#ca0020")) +
        ylim(-0.75, 1.75) +
        facet_wrap(~comparison) +
        xlab("") + ylab(bquote(paste("Difference in ", mu))) +
        coord_flip() +
        theme_bw(base_size = 18) +
        theme() +
        theme(legend.position="none")
    
    p
}

comparison_plots_article_3 <- plot_comp_article(comp_article_3, filter_genus_3)

comparison_plots_article_3
```

```{r}
library(ggpubr)
ggarrange(
    comparison_plots[[1]][[1]], comparison_plots[[2]][[1]],
    comparison_plots[[1]][[2]] + ylab(""), comparison_plots[[2]][[2]],
    nrow = 2, ncol = 2, common.legend = T
)


ggarrange(
    comparison_plots[[3]][[1]], comparison_plots[[4]][[1]],
    comparison_plots[[3]][[2]] + ylab(""), comparison_plots[[4]][[2]],
    nrow = 2, ncol = 2, common.legend = T
)
```

```{r}
library(ggrepel)
mu <- expression(mu)
differential_abundance_plots <- map2(comp_all_nested$data, comp_all_nested$comparison, ~.x %>% 
    arrange(prob) %>% 
    mutate(qvalue = cummean(prob)) %>%
    ggplot(aes(mean, prob, color = ifelse(prob <= 0.025 | prob >= 0.975, "sig", "notsig"), label = ifelse(abs(mean)>= 0.2, genus, ""))) +
        geom_point() + 
        xlim(-1, 1) +
        ggtitle(.y) +
        scale_colour_manual(values = c("sig" = "red", "notsig" = "black")) +
        geom_text_repel() +
        theme_bw() +
        xlab(bquote(paste("Difference in ", mu))) + ylab("P(Difference < 0)") +
        theme(legend.position="none") 
   
   )
#differential_abundance_plots

comp_article <- comp_all_df %>% filter(comparison %in% c("ccpre_noccpre", "ccpost_noccpost", "ccpost_ccpre", "noccpost_noccpre"))

differential_abundance_plots_article <- comp_article %>% 
    arrange(prob) %>% 
    mutate(qvalue = cummean(prob)) %>%
    ggplot(aes(mean, prob, color = ifelse(prob <= 0.05 | prob >= 0.95, "sig", "notsig"), label = ifelse(abs(mean)>= 0.2, genus, ""))) +
        geom_point() + 
        xlim(-1, 1) +
        scale_colour_manual(values = c("sig" = "red", "notsig" = "black")) +
        geom_text_repel(size = 2) +
        facet_wrap(~comparison) +
        theme_bw() +
        theme(legend.position="none") 
differential_abundance_plots[[8]]
```

```{r}
# how often do we find differences per parameter/comparison?
comp_all_df %>%
    filter(prob < 0.025 | prob > 0.975) %>%
    group_by(comparison) %>%
    summarise(n = n())


comp_all_df %>%
    filter(prob < 0.025 | prob > 0.975, abs(mean) >= 0.15, comparison %in% c("ccpre_noccpre", "ccpost_noccpost", "ccpost_ccpre", "noccpost_noccpre", "bf", "age")) %>%
    select(-prob) %>%
    arrange(desc(abs(mean))) %>%
    mutate_if(is.numeric, round, 2)
```

```{r}
# how are the probabilities distributes? In my understanding, if there is no difference between ccpost
# and the other groups, thus the parameter mu is the same, then the probability that group difference is <0 should be close to 50%. 
# If the parameters where not similar but in a non-systematic way, then p should be uniformly distributed ?!
# But if there is a systematic difference I would expect p mostly either < 0.05 or >0.95
comp_all_df %>%
    ggplot(aes(comparison, prob)) +
    geom_violin() +
    geom_jitter(alpha = 0.5, width = 0.05) +
    coord_flip()

comp_all_df %>% 
    ggplot(aes(prob)) +
    geom_density() +
    facet_wrap(~comparison)
```

```{r}
data2 <- data
levels(data2$cc) <- c("HOME", "CC")
levels(data2$cc)
levels(data2$time) <- c("PRE", "POST")
```

```{r}
# to further understand the difference between age and time and streptococcus etc
abundant_genera <- c("Streptococcusmitisetrel", "Streptococcusbovisetrel", "Streptococcusintermediusetrel", "Granulicatella")
visualize_abundance <- function(genus) {
    ggplot(data2, aes_string("time", genus, group = "subject_id", color = "Age")) +
    geom_point(size = 5) +
    geom_path(size = 1) +
    facet_wrap(~cc) +
    theme_bw()+
    xlab("") +
    theme_bw(base_size = 30) +
    theme(legend.position = "none") 
}
visualize_age_vs_abundance <- function(genus) {
    ggplot(data2, aes_string("Age", genus)) +
    geom_point() +
    geom_smooth() +
    facet_wrap(~cc*time)+
    xlab("")
}
visualize_bf_vs_abundance <- function(genus) {
    ggplot(data2, aes_string("bf_count_s", genus)) +
    geom_point() +
    geom_smooth() +
    facet_wrap(~cc) +
    xlab("")
}
data2$subject_id <-  as.factor(data2$subject_id)
data2$time <-  as.factor(data2$time)
#data2 <- data2 %>% rename(Age = age_d) %>% arrange(subject_id, time)
abundance_paths <- map(abundant_genera, visualize_abundance)
abundance_paths
map(abundant_genera, visualize_age_vs_abundance)
map(abundant_genera, visualize_bf_vs_abundance)
```

```{r}
data %>% group_by(cc, time) %>% summarise(mean(age_d_s), sd(age_d_s))
```

### Differential abundance LME4

```{r}
library(lme4)
library(car)
library(qvalue)
```

```{r}
# change contrasts for easy interpretability
reverse_c <- function(data) {
    contrasts(data$cc)[1, 1] <- 1
    contrasts(data$cc)[2, 1] <- 0
    contrasts(data$time)[1, 1] <- 1
    contrasts(data$time)[2, 1] <- 0
    data
}
data_imp_revc <- map(data_imp, reverse_c)
```

```{r}
# test if it worked
data_imp_revc[[1]]$time %>% contrasts()
```

```{r}
plan(multiprocess)
# fit models and pool estimates
lme4_fits <- 
    future_map(genus[-1], ~ data_imp_revc %>%
      map(lmer, formula = glue("{.x} ~ cc*time + age_d_s + bf_count_s + (1|subject_id)")) %>%
      pool() %>%
      summary() %>%
      rownames_to_column("parameter") %>%
      mutate(parameter = c("intercept", "cc", "time", "age", "breastfeeding", "cc_time")) %>%
      add_column(genus = .x) 
    )
```

```{r}
lme4_by_param <- lme4_fits %>% 
    map_df(bind_rows) %>%
    filter(parameter != "intercept") %>%
    group_by(parameter) %>%
    nest()
```

```{r}
lme4_by_param$parameter
```

```{r}
# calculate q value for each set of parameters, allow for 25% false discoveries
lme4_by_param$data <- map(lme4_by_param$data, ~.x %>% mutate(q = qvalue(p.value)$qvalue))

lme4_final <- lme4_by_param %>% unnest()
lme4_table <- lme4_final %>% 
    filter(p.value<=0.05, q <= 0.2) %>%
    arrange(parameter, desc(abs(estimate))) %>%
    mutate_if(is.numeric, round, 2) %>%
    select(parameter, genus, everything())
```

```{r}
library(ggrepel)

params <- c("cc", "time", "age", "breastfeeding")

plot_comp <- function(comp, data) {
    all_comp <- data %>% mutate(p = report_star(p.value)) %>% filter(parameter == comp)
    n_genera <- length(all_comp$genus)
    part1 <- all_comp[1:n_genera/2, ]
    part2 <- all_comp[-c(1:n_genera/2), ]
    p <- map(list(part1, part2), ~ ggplot(
        .x, aes(genus, estimate, label = p)) +
        geom_pointrange(aes(ymin = estimate - 2*std.error, ymax =estimate + 2*std.error), size = 0.2) +
        theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        geom_text(nudge_y = 1) +
        geom_hline(yintercept = 0, linetype = "dashed", color = "blue") +
        ylim(-2, 2) +
        ggtitle(comp) +
        coord_flip() +
        theme_bw(base_size = 8))
    
    p
}

lme4_plots <- map(params, plot_comp, lme4_final)
```

```{r}
library(grid)

#grid.draw(cbind(ggplotGrob(lme4_plots[[1]][[1]]), ggplotGrob(lme4_plots[[1]][[2]]), size = "last"))
grid.draw(cbind(ggplotGrob(lme4_plots[[2]][[1]]), ggplotGrob(lme4_plots[[2]][[2]]), size = "last"))
#grid.draw(cbind(ggplotGrob(lme4_plots[[3]][[1]]), ggplotGrob(lme4_plots[[3]][[2]]), size = "last"))
#grid.draw(cbind(ggplotGrob(lme4_plots[[4]][[1]]), ggplotGrob(lme4_plots[[4]][[2]]), size = "last"))
```

```{r}
lme4_final_table <-  lme4_final
colnames(lme4_final_table) <- str_to_title(colnames(lme4_final_table))
lme4_final_table %>%
    rename(P = P.value) %>%
    filter(P<=0.05, Q <= 0.2) %>%
    arrange(Parameter, desc(abs(Estimate))) %>%
    mutate_if(is.numeric, round, 2) %>%
    select(Parameter, Genus, everything()) 
```

```{r}
str_to_title(colnames(lme4_final_table))
    
```

### Alpha diversity

```{r}
# fit models and pool estimates
lme4_fits_div <- 
    map(diversity_index, ~ data_imp_revc %>%
      future_map(lmer, formula = glue("{.x} ~ cc*time + age_d_s + bf_count_s + (1|subject_id)")) %>%
      pool() %>%
      summary() %>%
      rownames_to_column("parameter") %>%
      mutate(parameter = c("intercept", "cc", "time", "age", "breastfeeding", "cc_time")) %>%
      add_column(index = .x) 
    )
```

```{r}
lme4_by_param_div <- lme4_fits_div %>% 
    map_df(bind_rows) %>%
    filter(parameter != "intercept") %>%
    group_by(parameter) %>%
    nest()
```

```{r}
# calculate q value for each set of parameters, allow for 25% false discoveries
#lme4_by_param_div$data <- map(lme4_by_param_div$data, ~.x %>% mutate(q = qvalue(p.value)$qvalue))
lme4_final_div <- lme4_by_param_div %>% unnest()
lme4_final_div %>%
    arrange(parameter, desc(abs(estimate))) %>%
    mutate_if(is.numeric, round, 2) %>%
    select(parameter, index, everything())
```

```{r}
data %>% 
    group_by(time, cc) %>% 
    summarise(
        shannon = glue("M = {round(mean(shannon), 2)}, SD = {round(sd(shannon), 2)}"),
        inverse_simpson = glue("M = {round(mean(inverse_simpson),2)}, SD = {round(sd(inverse_simpson), 2)}"),
        gini_simpson = glue("M = {round(mean(gini_simpson),2)}, SD = {round(sd(gini_simpson), 2)}")
    )
```

```{r}
save.image(file = here("data/cc_analyses_workspace.RData"))
# save the dataframe for Gerben
saveRDS(data, file = here("data/data_cc.rds"))
```

```{r}
ggplot(data_transfer, aes(bf_count, ))
```

```{r}
data_transfer %>% colnames()
```

## K-means
Just for exercise and curiosity and test if there is clustering

```{r}
genus_dist <- otus.clr %>% 
    column_to_rownames("sample_id") %>%
    dist(method = "euclidean")
plot(genus_dist)
```

```{r}
# find optimal number based on SI and elbow method:
si_ss <- map(1:10, function(k) {
    model_si <- cluster::pam(genus_dist, k = k)
    model_ss <- kmeans(genus_dist, centers = k)
    c(k = k, withinss = model_ss$tot.withinss, si =model_si$silinfo$avg.width)
})
```

```{r}
map_df(si_ss, bind_rows) %>%
    gather(index, value, -k) %>%
    na.omit() %>%
    ggplot(aes(k, value)) +
    geom_point() +
    geom_line() +
    scale_x_continuous(breaks = c(0:10)) +
    facet_wrap(~index, scales = "free")
```

```{r}
k_model <- kmeans(genus_dist, center = 2)
k_model$cluster %>% as.data.frame() %>%
    rownames_to_column("sample_id") %>%
    rename(cluster = ".") %>%
    left_join(data, by = "sample_id") %>%
    group_by(cluster, cc, time) %>%
    summarise(n = n())
```

```{r}
pseq.clr2 <- pseq.clr
```

```{r}
k_model <- kmeans(genus_dist, center = 2)
k_model$cluster %>% as.data.frame() %>%
    rownames_to_column("sample_id") %>%
    rename(cluster = ".") %>%
    left_join(data, by = "sample_id") %>%
    select(-contains("PC")) %>%
    df_to_sd() -> sample_data(pseq.clr2)
biplot(pseq.clr2, color = "cluster")
```

```{r}
chunk2 <- function(x,n) split(x, cut(seq_along(x), n, labels = FALSE)) 
otus_ctr <- column_to_rownames(otus.clr, "sample_id")
map(chunk2(1:130, 6), ~otus_ctr[, .x] %>% 
        gather(genus, rel_ab) %>%
        ggplot(aes(genus, rel_ab)) +
        geom_boxplot() +
        ylim(-3, 10) +
        coord_flip()
   )
```

```{r}
data %>% group_by(csection, cc) %>% summarise(n = n())
biplot(pseq.clr, color = "csection")
```

```{r}
confounders %>% group_by(DELIVERY)
```

```{r}
```